{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Context = void 0;\nconst _ = require(\"lodash\");\nfunction getDataMapKey(path, location) {\n  return `${location}:${path}`;\n}\nclass Context {\n  constructor(fields, locations, stack, optional, message) {\n    this.fields = fields;\n    this.locations = locations;\n    this.stack = stack;\n    this.optional = optional;\n    this.message = message;\n    this._errors = [];\n    this.dataMap = new Map();\n  }\n  get errors() {\n    return this._errors;\n  }\n  getData() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {\n      requiredOnly: false\n    };\n    // Have to store this.optional in a const otherwise TS thinks the value could have changed\n    // when the functions below run\n    const {\n      optional\n    } = this;\n    const checks = options.requiredOnly && optional ? [value => value !== undefined, value => optional.nullable ? value != null : true, value => optional.checkFalsy ? value : true] : [];\n    return _([...this.dataMap.values()]).groupBy('originalPath').flatMap((instances, group) => {\n      const locations = _.uniqBy(instances, 'location');\n      // #331 - When multiple locations are involved, all of them must pass the validation.\n      // If none of the locations contain the field, we at least include one for error reporting.\n      // #458, #531 - Wildcards are an exception though: they may yield 0..* instances with different\n      // paths, so we may want to skip this filtering.\n      if (instances.length > 1 && locations.length > 1 && !group.includes('*')) {\n        const withValue = instances.filter(instance => instance.value !== undefined);\n        return withValue.length ? withValue : [instances[0]];\n      }\n      return instances;\n    }).filter(instance => checks.every(check => check(instance.value))).valueOf();\n  }\n  addFieldInstances(instances) {\n    instances.forEach(instance => {\n      this.dataMap.set(getDataMapKey(instance.path, instance.location), Object.assign({}, instance));\n    });\n  }\n  setData(path, value, location) {\n    const instance = this.dataMap.get(getDataMapKey(path, location));\n    if (!instance) {\n      throw new Error('Attempt to write data that did not pre-exist in context');\n    }\n    instance.value = value;\n  }\n  addError(message, valueOrNestedErrors, meta) {\n    const msg = message || this.message || 'Invalid value';\n    if (meta) {\n      this._errors.push({\n        value: valueOrNestedErrors,\n        msg: typeof msg === 'function' ? msg(valueOrNestedErrors, meta) : msg,\n        param: meta.path,\n        location: meta.location\n      });\n    } else {\n      this._errors.push({\n        msg,\n        param: '_error',\n        nestedErrors: valueOrNestedErrors\n      });\n    }\n  }\n}\nexports.Context = Context;","map":{"version":3,"names":["Object","defineProperty","exports","value","Context","_","require","getDataMapKey","path","location","constructor","fields","locations","stack","optional","message","_errors","dataMap","Map","errors","getData","options","arguments","length","undefined","requiredOnly","checks","nullable","checkFalsy","values","groupBy","flatMap","instances","group","uniqBy","includes","withValue","filter","instance","every","check","valueOf","addFieldInstances","forEach","set","assign","setData","get","Error","addError","valueOrNestedErrors","meta","msg","push","param","nestedErrors"],"sources":["C:/xz/delivery/src/node_modules/express-validator/src/context.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Context = void 0;\nconst _ = require(\"lodash\");\nfunction getDataMapKey(path, location) {\n    return `${location}:${path}`;\n}\nclass Context {\n    constructor(fields, locations, stack, optional, message) {\n        this.fields = fields;\n        this.locations = locations;\n        this.stack = stack;\n        this.optional = optional;\n        this.message = message;\n        this._errors = [];\n        this.dataMap = new Map();\n    }\n    get errors() {\n        return this._errors;\n    }\n    getData(options = { requiredOnly: false }) {\n        // Have to store this.optional in a const otherwise TS thinks the value could have changed\n        // when the functions below run\n        const { optional } = this;\n        const checks = options.requiredOnly && optional\n            ? [\n                (value) => value !== undefined,\n                (value) => (optional.nullable ? value != null : true),\n                (value) => (optional.checkFalsy ? value : true),\n            ]\n            : [];\n        return _([...this.dataMap.values()])\n            .groupBy('originalPath')\n            .flatMap((instances, group) => {\n            const locations = _.uniqBy(instances, 'location');\n            // #331 - When multiple locations are involved, all of them must pass the validation.\n            // If none of the locations contain the field, we at least include one for error reporting.\n            // #458, #531 - Wildcards are an exception though: they may yield 0..* instances with different\n            // paths, so we may want to skip this filtering.\n            if (instances.length > 1 && locations.length > 1 && !group.includes('*')) {\n                const withValue = instances.filter(instance => instance.value !== undefined);\n                return withValue.length ? withValue : [instances[0]];\n            }\n            return instances;\n        })\n            .filter(instance => checks.every(check => check(instance.value)))\n            .valueOf();\n    }\n    addFieldInstances(instances) {\n        instances.forEach(instance => {\n            this.dataMap.set(getDataMapKey(instance.path, instance.location), Object.assign({}, instance));\n        });\n    }\n    setData(path, value, location) {\n        const instance = this.dataMap.get(getDataMapKey(path, location));\n        if (!instance) {\n            throw new Error('Attempt to write data that did not pre-exist in context');\n        }\n        instance.value = value;\n    }\n    addError(message, valueOrNestedErrors, meta) {\n        const msg = message || this.message || 'Invalid value';\n        if (meta) {\n            this._errors.push({\n                value: valueOrNestedErrors,\n                msg: typeof msg === 'function' ? msg(valueOrNestedErrors, meta) : msg,\n                param: meta.path,\n                location: meta.location,\n            });\n        }\n        else {\n            this._errors.push({\n                msg,\n                param: '_error',\n                nestedErrors: valueOrNestedErrors,\n            });\n        }\n    }\n}\nexports.Context = Context;\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}